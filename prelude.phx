true: 0 0 = ;
false: 0 1 = ;

not: 'false 'true if ;
eq: ('true 'false if) 'not if ;
xor: eq not ;
and: () (drop false) if ;
or: dup 'nip 'drop if ;

2drop: drop drop ;

keep: over 'call dip ;
bi: 'keep dip call ;
tri: ('keep dip keep) dip call ;

2curry: curry curry ;
with: swapd (swapd call) 2curry ;
cleave: 'call with each ;

2dip: swap 'dip dip ;
2keep: '2dup dip 2dip ;
2bi: '2keep dip call ;

bi*: 'dip dip call ;
2bi*: '2dip dip call ;
bi@: dup bi* ;
2bi@: dup 2bi* ;

+-: '+ '- 2bi ;

first: 0 nth ;
last: -1 nth ;

part: ['f] <- (f select) (f reject) bi ;

rotd: 'rot dip ;
roll: rotd swap ;

forever: 'true swap while ;

unless: swap if ;
when: () if ;
when*: over 'call '2drop if ;
while*: ('dup compose) dip while drop ;

prepose: swap compose ;

reduce: swapd each ;
zipwith: 'zip dip map ;

replicate: [ ] ['v] <-
  (v >> drop) compose swap times v ;
accumulate: [ ] ['v] <-
  (over v >> drop) prepose reduce v ;
produce: [ ] ['v] <-
  (v >> drop) compose while v ;

min: 2dup < 'drop 'nip if ;
max: 2dup > 'drop 'nip if ;
neg: -1 * ;
sign: [(0 >) (drop 1)
       (0 <) (drop -1)] cond ;
abs: dup sign * ;

flat1: [] ['v] <-
  (dup vec?
   ((v >> drop) each)
    (v >> drop) if) each v ;

# TODO: This can definitely be a lot cleaner.
cart*: [] ['b 'v] <-
  (b (over swap 2 ->vec dup v >> drop) map drop) map drop v ;
